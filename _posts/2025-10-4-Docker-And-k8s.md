---
title: Docker和k8s学习笔记
author: Zpekii
tags: [docker,Kubernetes]
categories: [Learning,容器]
---

# Docker

### 基本使用

- 创建容器: `docker run` 如果镜像不存在则会先进行拉取
- 拉取镜像: `docker pull`
- 推送镜像到仓库: `docker push`
- 移除容器: `docker stop` + `docker rm` 在执行移除前需要先暂停容器
- 移除镜像: `docker rmi`
- 将容器导出为镜像: `docker commit`
- 将容器导出为镜像文件: `docker export`
- 导入镜像: `docker import`
- 创建一个bridge(NAT)网络: `docker network create`, 处于同一网络下的容器可以根据**容器名+端口**直接访问里面运行的程序
- 查看容器配置: `docker inspect`
- 查看容器日志: `docker logs` 加上 `-f` 参数实时获取最新日志
- 直接在容器里执行命令: `docker exec` ; 直接访问容器终端可执行 `docker exec -it {container name} bash` , `-it` 参数指分配一个交互终端 ,或执行 `docker attach` 直接访问容器,两者的区别在于前者会在容器中启动一个新的`bash`进程,而后者不会

### 什么是Docker

Docker是一个开源的应用容器引擎；我们可以使用它将应用程序和所需的环境依赖打包到一个轻量级、可移植的容器中，并且还可以构建镜像然后上传到仓库中进行分发，解决开发、测试和生产环境的一致性问题，避免出现“在我的机器上可以运行”的问题

### 容器和虚拟机的区别

首先容器相比于虚拟机体积小很多，容器里面只包含了最基本的命令、工具以及所需的应用程序库，直接使用的是主机的内核，几乎没有性能损耗，而虚拟机是包含了整一个操作系统，在创建和启动速度方面，容器也会快很多，基本上是秒级，可以快速迭代和部署，同时还可以保持高一致性

但是容器的安全性相对较弱，容器属于进程之间的隔离，有逃逸的风险，而虚拟机则是系统级别的隔离

### 容器和镜像的区别

镜像是只读的模板，里面包含了应用程序所需的执行文件、库、环境变量和配置文件等，是静态的，不可变的，持久化存在；容器是基于镜像创建的运行实例，是动态可变的，临时存在的，docker会为容器提供独立的与主机隔离的运行环境，可以对容器进行启动、停止和重启操作，并且还会在只读的镜像层上额外添加了一个可写层提供给容器进行数据的读写

### 容器创建过程





# Kubernetes

### 什么是Kubernetes

k8s 是一个开源的容器编排平台，主要用于容器化应用的自动化部署、扩展和管理，通过使用 k8s 我们可以实现负载均衡、高可用服务和自动伸缩; 

k8s 的集群架构简单来说，

它包含了一个控制平面组件，

- 控制平面组件里包含了API服务器kube-apiserver
- 持久化键值存储etcd
- 监视 Pod 状态的 kube-schedular
- 运行控制器的 kube-controller-manager
- 以及嵌入了特定云平台控制逻辑的 cloud-controller-manager

然后集群还包含一个或多个节点Node, 节点负责维护运行的Pod并提供 k8s 的运行时环境，

- 节点里面的 kubelet 会保证容器都运行在 Pod 中
- kube-proxy 是节点上运行的网络代理，会维护节点上的一些网路规则
- 容器运行时将保证容器能够有效的运行，负责管理k8s环境中的容器的执行和生命周期



### 为什么使用 k8s ，使用 k8s 做集群有什么优势

首先 k8s 是一个开源的容器编排平台，它基于的是容器技术，使用容器的好处是轻量、部署速度快、拥有良好的可移植性，并且使用容器可以保证开发、测试和生产环境的一致性；

其次，k8s 提供了自动化部署、负载均衡、自动伸缩和容器监控，运维成本更低，保证高可用的服务

### k8s 组成

首先 Pod 是 k8s 中最小的部署单元，通常包含一个或多个容器，运行在同一个网络命名空间，以及共享同一个存储卷；

其次 Deployment 用于创建和更新一组 Pod 实例，使得 Pod 可以按照预期进行运行; 

接着 Service 是一种抽象，用于将一个或一组 Pod 在网络上公开出去，默认的类型是 ClusterIP ，向集群内部公开，配置为 LoadBalancer 时，向外部公开；

然后 Ingress 用于配置外部访问集群内服务的 HTTP 和 HTTPS 的路由, 为 Service 配置可访问的 URL, 并对其流量做负载均衡



